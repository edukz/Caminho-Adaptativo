<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>A* Adaptativo - Simulador Interativo</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(45deg, #2196F3, #21CBF3);
            color: white;
            padding: 20px;
            text-align: center;
        }
        
        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
        }
        
        .main-content {
            display: grid;
            grid-template-columns: 1fr 350px;
            gap: 20px;
            padding: 20px;
        }
        
        .simulation-area {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .grid {
            display: grid;
            grid-template-columns: repeat(10, 45px);
            gap: 2px;
            margin: 20px 0;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 15px;
            box-shadow: inset 0 2px 10px rgba(0,0,0,0.1);
            position: relative; /* Importante para posicionamento do personagem */
        }
        
        .cell {
            width: 45px;
            height: 45px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 12px;
            position: relative;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .cell:hover {
            transform: scale(1.1);
            z-index: 10;
        }
        
        .coords {
            font-size: 8px;
            position: absolute;
            top: 2px;
            left: 2px;
            color: #666;
        }
        
        .cost-info {
            font-size: 8px;
            position: absolute;
            bottom: 2px;
            right: 2px;
            background: rgba(255,255,255,0.8);
            padding: 1px 3px;
            border-radius: 3px;
        }
        
        /* Estilos das c√©lulas */
        .start { 
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
            box-shadow: 0 4px 8px rgba(76, 175, 80, 0.3);
        }
        .goal { 
            background: linear-gradient(45deg, #f44336, #d32f2f);
            color: white;
            box-shadow: 0 4px 8px rgba(244, 67, 54, 0.3);
        }
        .obstacle { 
            background: linear-gradient(45deg, #333, #555);
            color: white;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        .path { 
            background: linear-gradient(45deg, #2196F3, #1976D2);
            color: white;
            animation: pulse 2s infinite;
        }
        .explored { 
            background: linear-gradient(45deg, #FFC107, #FF9800);
            animation: fadeIn 0.5s ease-in;
        }
        .frontier { 
            background: linear-gradient(45deg, #FF9800, #F57C00);
            animation: bounce 1s infinite;
        }
        .dynamic-obstacle { 
            background: linear-gradient(45deg, #9C27B0, #7B1FA2);
            color: white;
            animation: shake 0.5s ease-in-out;
        }
        .new-path { 
            background: linear-gradient(45deg, #00BCD4, #0097A7);
            color: white;
            animation: slideIn 0.5s ease-out;
        }
        .visited { 
            background: linear-gradient(45deg, #8BC34A, #689F38);
            color: white;
            animation: visitedPulse 0.5s ease-out;
        }
        .detour { 
            background: linear-gradient(45deg, #FF5722, #E64A19);
            color: white;
            animation: detourGlow 0.8s ease-out;
            box-shadow: 0 0 10px rgba(255, 87, 34, 0.5);
        }
        .stepped { 
            background: linear-gradient(45deg, #2196F3, #1565C0);
            color: white;
            animation: steppedPulse 0.3s ease-out;
            box-shadow: 0 0 8px rgba(33, 150, 243, 0.4);
        }
        .custom-path { 
            background: linear-gradient(45deg, #E91E63, #C2185B);
            color: white;
            animation: customPathPulse 1s ease-in-out infinite;
            box-shadow: 0 0 12px rgba(233, 30, 99, 0.6);
        }
        .waypoint { 
            background: linear-gradient(45deg, #9C27B0, #7B1FA2);
            color: white;
            animation: waypointGlow 2s ease-in-out infinite;
            box-shadow: 0 0 15px rgba(156, 39, 176, 0.8);
        }
        
        /* Estilos do bonequinho */
        .character {
            position: absolute;
            width: 35px;
            height: 35px;
            border-radius: 50%;
            background: linear-gradient(45deg, #FF6B35, #F7931E);
            border: 3px solid #fff;
            box-shadow: 0 4px 15px rgba(255, 107, 53, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            z-index: 100;
            transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            pointer-events: none;
        }
        
        .character.moving {
            animation: bounce-walk 0.3s ease-in-out;
        }
        
        .character::before {
            content: 'ü§ñ';
            animation: character-idle 2s ease-in-out infinite;
        }
        
        .character.walking::before {
            content: 'üèÉ';
            animation: character-walk 0.3s ease-in-out infinite;
        }
        
        .character.blocked::before {
            content: 'üòµ';
            animation: character-confused 0.5s ease-in-out infinite;
        }
        
        .character.celebrating::before {
            content: 'üéâ';
            animation: character-celebrate 1s ease-in-out;
        }
        
        @keyframes bounce-walk {
            0%, 100% { transform: translateY(0) scale(1); }
            50% { transform: translateY(-8px) scale(1.1); }
        }
        
        @keyframes character-idle {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        
        @keyframes character-walk {
            0%, 100% { transform: rotate(-5deg) scale(1); }
            50% { transform: rotate(5deg) scale(1.1); }
        }
        
        @keyframes character-confused {
            0%, 100% { transform: rotate(0deg); }
            25% { transform: rotate(-10deg); }
            75% { transform: rotate(10deg); }
        }
        
        @keyframes character-celebrate {
            0%, 100% { transform: scale(1) rotate(0deg); }
            25% { transform: scale(1.2) rotate(10deg); }
            50% { transform: scale(1.1) rotate(-10deg); }
            75% { transform: scale(1.3) rotate(5deg); }
        }
        
        /* Rastro do movimento */
        .trail {
            position: absolute;
            width: 20px;
            height: 20px;
            background: radial-gradient(circle, rgba(255, 107, 53, 0.6), transparent);
            border-radius: 50%;
            pointer-events: none;
            animation: trail-fade 1s ease-out forwards;
        }
        
        @keyframes trail-fade {
            0% { 
                opacity: 0.8;
                transform: scale(1);
            }
            100% { 
                opacity: 0;
                transform: scale(2);
            }
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-5px); }
        }
        
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }
        
        @keyframes slideIn {
            from { transform: translateX(-20px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        
        @keyframes visitedPulse {
            0% { transform: scale(1); opacity: 0.8; }
            50% { transform: scale(1.1); opacity: 1; }
            100% { transform: scale(1); opacity: 0.9; }
        }
        
        @keyframes detourGlow {
            0% { 
                transform: scale(1); 
                box-shadow: 0 0 5px rgba(255, 87, 34, 0.3);
            }
            50% { 
                transform: scale(1.15); 
                box-shadow: 0 0 20px rgba(255, 87, 34, 0.8);
            }
            100% { 
                transform: scale(1); 
                box-shadow: 0 0 10px rgba(255, 87, 34, 0.5);
            }
        }
        
        @keyframes steppedPulse {
            0% { 
                transform: scale(1); 
                box-shadow: 0 0 5px rgba(33, 150, 243, 0.3);
            }
            50% { 
                transform: scale(1.1); 
                box-shadow: 0 0 15px rgba(33, 150, 243, 0.6);
            }
            100% { 
                transform: scale(1); 
                box-shadow: 0 0 8px rgba(33, 150, 243, 0.4);
            }
        }
        
        @keyframes customPathPulse {
            0%, 100% { 
                transform: scale(1); 
                box-shadow: 0 0 8px rgba(233, 30, 99, 0.4);
            }
            50% { 
                transform: scale(1.08); 
                box-shadow: 0 0 18px rgba(233, 30, 99, 0.8);
            }
        }
        
        @keyframes waypointGlow {
            0%, 100% { 
                transform: scale(1) rotate(0deg); 
                box-shadow: 0 0 10px rgba(156, 39, 176, 0.6);
            }
            50% { 
                transform: scale(1.2) rotate(5deg); 
                box-shadow: 0 0 25px rgba(156, 39, 176, 1);
            }
        }
        
        .controls-panel {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 20px;
            height: fit-content;
        }
        
        .controls-section {
            margin-bottom: 25px;
        }
        
        .controls-section h3 {
            color: #2196F3;
            margin-bottom: 15px;
            font-size: 1.2rem;
        }
        
        .button-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        button {
            background: linear-gradient(45deg, #2196F3, #21CBF3);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(33, 150, 243, 0.3);
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(33, 150, 243, 0.4);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        button.danger {
            background: linear-gradient(45deg, #f44336, #d32f2f);
            box-shadow: 0 4px 15px rgba(244, 67, 54, 0.3);
        }
        
        button.success {
            background: linear-gradient(45deg, #4CAF50, #45a049);
            box-shadow: 0 4px 15px rgba(76, 175, 80, 0.3);
        }
        
        .legend {
            display: grid;
            grid-template-columns: 1fr;
            gap: 8px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .legend-cell {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        
        .stats {
            background: white;
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .stat-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            padding: 5px 0;
            border-bottom: 1px solid #eee;
        }
        
        .mode-selector {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .mode-btn {
            flex: 1;
            padding: 8px;
            font-size: 12px;
        }
        
        .mode-btn.active {
            background: linear-gradient(45deg, #4CAF50, #45a049);
        }
        
        .speed-control {
            margin: 15px 0;
        }
        
        .speed-slider {
            width: 100%;
            margin: 10px 0;
        }
        
        .comparison {
            background: linear-gradient(45deg, #e3f2fd, #bbdefb);
            border-radius: 10px;
            padding: 15px;
            margin-top: 15px;
        }
        
        .comparison h4 {
            color: #1976D2;
            margin-bottom: 10px;
        }
        
        .vs-item {
            display: flex;
            justify-content: space-between;
            margin: 8px 0;
            font-size: 14px;
        }
        
        /* Sistema de Log */
        .log-system {
            background: #f8f9fa;
            border: 2px solid #e9ecef;
            border-radius: 10px;
            margin-top: 20px;
            overflow: hidden;
        }
        
        .log-header {
            background: linear-gradient(45deg, #6c757d, #495057);
            color: white;
            padding: 12px 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .log-header h4 {
            margin: 0;
            font-size: 16px;
        }
        
        .log-controls {
            display: flex;
            gap: 8px;
        }
        
        .log-btn {
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .log-btn:hover {
            background: rgba(255, 255, 255, 0.3);
        }
        
        .log-container {
            max-height: 300px;
            overflow-y: auto;
            padding: 10px;
            background: white;
        }
        
        .log-entry {
            display: flex;
            align-items: flex-start;
            gap: 10px;
            padding: 8px;
            border-radius: 6px;
            margin-bottom: 4px;
            font-size: 13px;
            border-left: 4px solid transparent;
            animation: logEntryFadeIn 0.3s ease-out;
        }
        
        @keyframes logEntryFadeIn {
            from { opacity: 0; transform: translateX(-10px); }
            to { opacity: 1; transform: translateX(0); }
        }
        
        .log-entry.system {
            background: #e3f2fd;
            border-left-color: #2196F3;
        }
        
        .log-entry.movement {
            background: #e8f5e8;
            border-left-color: #4CAF50;
        }
        
        .log-entry.obstacle {
            background: #fff3e0;
            border-left-color: #FF9800;
        }
        
        .log-entry.error {
            background: #ffebee;
            border-left-color: #f44336;
        }
        
        .log-entry.success {
            background: #e8f5e8;
            border-left-color: #4CAF50;
            font-weight: bold;
        }
        
        .log-entry.pathfinding {
            background: #f3e5f5;
            border-left-color: #9C27B0;
        }
        
        .log-time {
            font-family: 'Courier New', monospace;
            font-weight: bold;
            color: #666;
            min-width: 65px;
            font-size: 11px;
        }
        
        .log-message {
            flex: 1;
            line-height: 1.4;
        }
        
        .log-coordinates {
            background: #e9ecef;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-weight: bold;
        }
        
        .interactive-hint {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 8px;
            padding: 10px;
            margin: 10px 0;
            font-size: 14px;
        }
        
        @media (max-width: 768px) {
            .main-content {
                grid-template-columns: 1fr;
            }
            
            .grid {
                grid-template-columns: repeat(8, 35px);
            }
            
            .cell {
                width: 35px;
                height: 35px;
                font-size: 10px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üéÆ A* Adaptativo - Simulador Interativo</h1>
            <p>Demonstra√ß√£o visual do algoritmo de pathfinding mais inteligente</p>
        </div>
        
        <div class="main-content">
            <div class="simulation-area">
                <div class="interactive-hint">
                    üí° <strong>Modo Interativo:</strong> Clique nas c√©lulas para adicionar/remover obst√°culos e veja o algoritmo se adaptar em tempo real!
                </div>
                
                <div id="current-step-info" class="step-info"></div>
                <div class="grid" id="grid"></div>
                
                <div class="comparison" id="comparison" style="display: none;">
                    <h4>‚ö° Compara√ß√£o de Performance</h4>
                    <div class="vs-item">
                        <span>A* Tradicional:</span>
                        <span id="traditional-cost">--</span>
                    </div>
                    <div class="vs-item">
                        <span>A* Adaptativo:</span>
                        <span id="adaptive-cost">--</span>
                    </div>
                    <div class="vs-item" style="font-weight: bold; color: #4CAF50;">
                        <span>Economia:</span>
                        <span id="savings">--</span>
                    </div>
                </div>

                <!-- Sistema de Log -->
                <div class="log-system">
                    <div class="log-header">
                        <h4>üìã Log do Sistema</h4>
                        <div class="log-controls">
                            <button onclick="clearLog()" class="log-btn">üóëÔ∏è Limpar</button>
                            <button onclick="toggleAutoScroll()" class="log-btn" id="auto-scroll-btn">üìú Auto-scroll: ON</button>
                        </div>
                    </div>
                    <div class="log-container" id="log-container">
                        <div class="log-entry system">
                            <span class="log-time">00:00:00</span>
                            <span class="log-message">Sistema iniciado - Pronto para navega√ß√£o!</span>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="controls-panel">
                <div class="controls-section">
                    <h3>üéõÔ∏è Controles</h3>
                    <div class="mode-selector">
                        <button class="mode-btn active" onclick="setMode('demo')" id="demo-btn">Demo</button>
                        <button class="mode-btn" onclick="setMode('interactive')" id="interactive-btn">Interativo</button>
                        <button class="mode-btn" onclick="setMode('custom')" id="custom-btn">üé® Desenhar</button>
                    </div>
                    
                    
                    <!-- Controles de desenho - APENAS os solicitados -->
                    <div class="button-group">
                        <button onclick="togglePathDrawing()" id="draw-toggle-btn" class="success">‚úèÔ∏è Iniciar Desenho</button>
                        <button onclick="addWaypoint()" style="background: linear-gradient(45deg, #9C27B0, #7B1FA2);">‚≠ê Modo Waypoint</button>
                        <button onclick="addRandomPokemon()" style="background: linear-gradient(45deg, #9C27B0, #7B1FA2);">üêõ Pok√©mon Aleat√≥rio</button>
                        <button onclick="addRandomObstacle()" class="danger">üé≤ Obst√°culo Aleat√≥rio</button>
                        <button onclick="clearFootprints()" style="background: linear-gradient(45deg, #9C27B0, #7B1FA2);">üë£ Limpar Pegadas</button>
                        <button onclick="clearCustomPath()" class="danger">üóëÔ∏è Apagar Desenho</button>
                        <button onclick="followCustomPath()" style="background: linear-gradient(45deg, #FF9800, #F57C00);">üöÄ Seguir Meu Caminho</button>
                    </div>
                    
                </div>
                
                <div class="controls-section">
                    <h3>üìä Estat√≠sticas</h3>
                    <div class="stats">
                        <div class="stat-item">
                            <span>C√©lulas Processadas:</span>
                            <span id="cells-processed">0</span>
                        </div>
                        <div class="stat-item">
                            <span>Obst√°culos Din√¢micos:</span>
                            <span id="dynamic-obstacles">0</span>
                        </div>
                        <div class="stat-item">
                            <span>Replanejamentos:</span>
                            <span id="replanning-count">0</span>
                        </div>
                        <div class="stat-item">
                            <span>Comprimento do Caminho:</span>
                            <span id="path-length">0</span>
                        </div>
                    </div>
                </div>
                
                <div class="controls-section">
                    <h3>üè∑Ô∏è Legenda</h3>
                    <div class="legend">
                        <div class="legend-item">
                            <div class="legend-cell start"></div>
                            <span>In√≠cio (S)</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-cell goal"></div>
                            <span>Destino (G)</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-cell obstacle"></div>
                            <span>Obst√°culo (#)</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-cell path"></div>
                            <span>Caminho Atual</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-cell dynamic-obstacle"></div>
                            <span>Pok√©mon (P)</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-cell custom-path"></div>
                            <span>Caminho Desenhado (‚úèÔ∏è)</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-cell waypoint"></div>
                            <span>Waypoint (‚≠ê)</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-cell stepped"></div>
                            <span>Pisou Aqui (üë£)</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-cell visited"></div>
                            <span>Caminho Percorrido (‚Ä¢)</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-cell detour"></div>
                            <span>Desvio de Obst√°culo (‚Üó)</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-cell new-path"></div>
                            <span>Novo Caminho</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-cell explored"></div>
                            <span>Explorado</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-cell frontier"></div>
                            <span>Fronteira</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const GRID_SIZE = 10;
        let currentStepIndex = 0;
        let autoPlayInterval = null;
        let currentMode = 'demo';
        let playbackSpeed = 2000;
        let walkingSpeed = 500;
        let isWalking = false;
        let character = null;
        let walkingInterval = null;
        let currentWalkStep = 0;
        let autoScroll = true;
        let startTime = Date.now();
        let isDrawingPath = false;
        let isMouseDown = false;
        let gameState = {
            start: [0, 0],
            goal: [9, 9],
            obstacles: [[2,2], [2,3], [3,3], [5,5], [5,6], [6,5], [7,8]],
            dynamicObstacles: [],
            currentPath: [],
            customPath: [], // Caminho personalizado desenhado pelo usu√°rio
            waypoints: [], // Pontos de passagem obrigat√≥rios
            visitedCells: [], // C√©lulas que o rob√¥ j√° visitou
            steppedCells: [], // C√©lulas que o rob√¥ REALMENTE pisou
            detourCells: [], // C√©lulas visitadas durante desvios
            originalPath: [], // Caminho original antes dos desvios
            isOnDetour: false, // Flag para indicar se est√° desviando
            stats: {
                cellsProcessed: 0,
                dynamicObstacles: 0,
                replanningCount: 0,
                pathLength: 0
            }
        };

        const demoSteps = [
            {
                title: "üéØ Cen√°rio Inicial",
                description: "Bot precisa ir de (0,0) para (9,9). Alguns obst√°culos j√° existem no mapa.",
                obstacles: [[2,2], [2,3], [3,3], [5,5], [5,6], [6,5], [7,8]],
                dynamicObstacles: [],
                currentPath: [],
                showComparison: false
            },
            {
                title: "üß† Calculando Caminho Original",
                description: "A* encontra o melhor caminho evitando obst√°culos est√°ticos.",
                obstacles: [[2,2], [2,3], [3,3], [5,5], [5,6], [6,5], [7,8]],
                dynamicObstacles: [],
                currentPath: [[0,0], [1,1], [1,2], [1,3], [1,4], [2,5], [3,6], [4,7], [5,8], [6,9], [7,9], [8,9], [9,9]],
                showComparison: false
            },
            {
                title: "‚ö†Ô∏è Pok√©mon Aparece!",
                description: "Um Pok√©mon selvagem bloqueia o caminho em (1,2)!",
                obstacles: [[2,2], [2,3], [3,3], [5,5], [5,6], [6,5], [7,8]],
                dynamicObstacles: [[1,2]],
                currentPath: [[0,0], [1,1]],
                blockedPath: [[1,2], [1,3], [1,4], [2,5], [3,6], [4,7], [5,8], [6,9], [7,9], [8,9], [9,9]],
                showComparison: false
            },
            {
                title: "üöÄ A* Adaptativo em A√ß√£o",
                description: "Mant√©m o progresso e recalcula apenas a parte necess√°ria.",
                obstacles: [[2,2], [2,3], [3,3], [5,5], [5,6], [6,5], [7,8]],
                dynamicObstacles: [[1,2]],
                currentPath: [[0,0], [1,1]],
                newPath: [[2,1], [3,2], [4,2], [4,3], [4,4], [4,5], [4,6], [4,7], [5,8], [6,9], [7,9], [8,9], [9,9]],
                showComparison: true,
                traditionalCost: "64 c√©lulas",
                adaptiveCost: "18 c√©lulas",
                savings: "72%"
            }
        ];

        function setMode(mode) {
            currentMode = mode;
            document.querySelectorAll('.mode-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById(mode + '-btn').classList.add('active');
            
            if (mode === 'interactive') {
                calculateAndShowPath();
            } else if (mode === 'custom') {
                enablePathDrawing();
            } else {
                disablePathDrawing();
                resetDemo();
            }
        }

        function updateSpeed(value) {
            playbackSpeed = parseInt(value);
            document.getElementById('speed-display').textContent = (value / 1000) + 's';
        }

        function updateStats() {
            document.getElementById('cells-processed').textContent = gameState.stats.cellsProcessed;
            document.getElementById('dynamic-obstacles').textContent = gameState.stats.dynamicObstacles;
            document.getElementById('replanning-count').textContent = gameState.stats.replanningCount;
            document.getElementById('path-length').textContent = gameState.stats.pathLength;
        }

        function updateGridVisually() {
            // Atualiza apenas o visual das c√©lulas sem recriar o grid inteiro
            for (let row = 0; row < GRID_SIZE; row++) {
                for (let col = 0; col < GRID_SIZE; col++) {
                    const cell = document.getElementById(`cell-${row}-${col}`);
                    if (!cell) continue;
                    
                    // Resetar classes (exceto coordenadas)
                    cell.className = 'cell';
                    
                    // Manter apenas as coordenadas
                    const coordDiv = cell.querySelector('.coords');
                    cell.innerHTML = '';
                    if (coordDiv) {
                        cell.appendChild(coordDiv);
                    }
                    
                    // Aplicar estilos baseados no estado atual (ORDEM IMPORTA!)
                    if (row === gameState.start[0] && col === gameState.start[1]) {
                        cell.className += ' start';
                        cell.innerHTML += '<div>S</div>';
                    } else if (row === gameState.goal[0] && col === gameState.goal[1]) {
                        cell.className += ' goal';
                        cell.innerHTML += '<div>G</div>';
                    } else if (gameState.obstacles.some(obs => obs[0] === row && obs[1] === col)) {
                        cell.className += ' obstacle';
                        cell.innerHTML += '<div>#</div>';
                    } else if (gameState.dynamicObstacles.some(obs => obs[0] === row && obs[1] === col)) {
                        cell.className += ' dynamic-obstacle';
                        cell.innerHTML += '<div>P</div>';
                    } else if (gameState.waypoints.some(p => p[0] === row && p[1] === col)) {
                        // PRIORIDADE: Waypoints definidos pelo usu√°rio
                        cell.className += ' waypoint';
                        cell.innerHTML += '<div>‚≠ê</div>';
                    } else if (gameState.steppedCells.some(p => p[0] === row && p[1] === col)) {
                        // C√©lulas que o rob√¥ REALMENTE pisou
                        cell.className += ' stepped';
                        cell.innerHTML += '<div>üë£</div>';
                    } else if (gameState.customPath.some(p => p[0] === row && p[1] === col)) {
                        // Caminho personalizado desenhado pelo usu√°rio
                        cell.className += ' custom-path';
                        cell.innerHTML += '<div>‚úèÔ∏è</div>';
                    } else if (gameState.detourCells.some(p => p[0] === row && p[1] === col)) {
                        cell.className += ' detour';
                        cell.innerHTML += '<div>‚Üó</div>';
                    } else if (gameState.visitedCells.some(p => p[0] === row && p[1] === col)) {
                        cell.className += ' visited';
                        cell.innerHTML += '<div>‚Ä¢</div>';
                    } else if (gameState.currentPath.some(p => p[0] === row && p[1] === col)) {
                        cell.className += ' path';
                        cell.innerHTML += '<div>‚Üí</div>';
                    }
                    
                    // Re-adicionar coordenadas se necess√°rio
                    if (!cell.querySelector('.coords')) {
                        const coordDiv = document.createElement('div');
                        coordDiv.className = 'coords';
                        coordDiv.textContent = row + ',' + col;
                        cell.appendChild(coordDiv);
                    }
                }
            }
        }

        function createGrid(stepData = null) {
            const grid = document.getElementById('grid');
            const stepInfo = document.getElementById('current-step-info');
            const comparison = document.getElementById('comparison');
            
            grid.innerHTML = '';
            
            // Remove personagem existente
            if (character) {
                character.remove();
                character = null;
            }
            
            if (stepData) {
                stepInfo.innerHTML = `<h3>${stepData.title}</h3><p>${stepData.description}</p>`;
                
                if (stepData.showComparison) {
                    comparison.style.display = 'block';
                    document.getElementById('traditional-cost').textContent = stepData.traditionalCost;
                    document.getElementById('adaptive-cost').textContent = stepData.adaptiveCost;
                    document.getElementById('savings').textContent = stepData.savings;
                } else {
                    comparison.style.display = 'none';
                }
            } else {
                stepInfo.innerHTML = '<h3>üéÆ Modo Interativo</h3><p>Clique nas c√©lulas para adicionar obst√°culos e veja o bonequinho se adaptar!</p>';
                comparison.style.display = 'none';
            }
            
            // Posi√ß√£o do grid para c√°lculos do personagem
            const gridRect = grid.getBoundingClientRect();
            
            for (let row = 0; row < GRID_SIZE; row++) {
                for (let col = 0; col < GRID_SIZE; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.row = row;
                    cell.dataset.col = col;
                    cell.id = `cell-${row}-${col}`;
                    
                    // Coordenadas
                    const coordDiv = document.createElement('div');
                    coordDiv.className = 'coords';
                    coordDiv.textContent = row + ',' + col;
                    cell.appendChild(coordDiv);
                    
                    // Evento de clique para modo interativo ou desenho
                    if (currentMode === 'interactive') {
                        cell.addEventListener('click', () => handleCellClick(row, col));
                    } else if (currentMode === 'custom') {
                        cell.addEventListener('mousedown', (e) => handlePathDrawingStart(row, col, e));
                        cell.addEventListener('mouseover', () => handlePathDrawingMove(row, col));
                        cell.addEventListener('mouseup', () => handlePathDrawingEnd(row, col));
                    }
                    
                    // Determinar tipo de c√©lula
                    const obstacles = stepData ? stepData.obstacles : gameState.obstacles;
                    const dynamicObstacles = stepData ? stepData.dynamicObstacles : gameState.dynamicObstacles;
                    const currentPath = stepData ? stepData.currentPath : gameState.currentPath;
                    
                    if (row === gameState.start[0] && col === gameState.start[1]) {
                        cell.className += ' start';
                        cell.innerHTML += '<div>S</div>';
                    } else if (row === gameState.goal[0] && col === gameState.goal[1]) {
                        cell.className += ' goal';
                        cell.innerHTML += '<div>G</div>';
                    } else if (obstacles && obstacles.some(obs => obs[0] === row && obs[1] === col)) {
                        cell.className += ' obstacle';
                        cell.innerHTML += '<div>#</div>';
                    } else if (dynamicObstacles && dynamicObstacles.some(obs => obs[0] === row && obs[1] === col)) {
                        cell.className += ' dynamic-obstacle';
                        cell.innerHTML += '<div>P</div>';
                    } else if (gameState.waypoints.some(p => p[0] === row && p[1] === col)) {
                        // PRIORIDADE: Waypoints definidos pelo usu√°rio
                        cell.className += ' waypoint';
                        cell.innerHTML += '<div>‚≠ê</div>';
                    } else if (gameState.steppedCells.some(p => p[0] === row && p[1] === col)) {
                        // C√©lulas que o rob√¥ REALMENTE pisou
                        cell.className += ' stepped';
                        cell.innerHTML += '<div>üë£</div>';
                    } else if (gameState.customPath.some(p => p[0] === row && p[1] === col)) {
                        // Caminho personalizado desenhado pelo usu√°rio
                        cell.className += ' custom-path';
                        cell.innerHTML += '<div>‚úèÔ∏è</div>';
                    } else if (gameState.detourCells.some(p => p[0] === row && p[1] === col)) {
                        cell.className += ' detour';
                        cell.innerHTML += '<div>‚Üó</div>';
                    } else if (gameState.visitedCells.some(p => p[0] === row && p[1] === col)) {
                        cell.className += ' visited';
                        cell.innerHTML += '<div>‚Ä¢</div>';
                    } else if (stepData && stepData.newPath && stepData.newPath.some(p => p[0] === row && p[1] === col)) {
                        cell.className += ' new-path';
                        cell.innerHTML += '<div>‚Üí</div>';
                    } else if (currentPath && currentPath.some(p => p[0] === row && p[1] === col)) {
                        cell.className += ' path';
                        cell.innerHTML += '<div>‚Üí</div>';
                    } else if (stepData && stepData.blockedPath && stepData.blockedPath.some(p => p[0] === row && p[1] === col)) {
                        cell.className += ' path';
                        cell.innerHTML += '<div>‚úó</div>';
                        cell.style.opacity = '0.3';
                    }
                    
                    grid.appendChild(cell);
                }
            }
            
            // Criar personagem na posi√ß√£o inicial
            createCharacter();
            updateStats();
            
            // Log da cria√ß√£o do grid
            if (currentMode === 'interactive') {
                addLogEntry('system', 'Grid atualizado - Caminho recalculado');
            }
        }

        function createCharacter() {
            if (character) {
                character.remove();
            }
            
            character = document.createElement('div');
            character.className = 'character';
            character.id = 'walking-character';
            
            // Posicionar o personagem na c√©lula inicial usando posicionamento relativo ao grid
            const startCell = document.getElementById(`cell-${gameState.start[0]}-${gameState.start[1]}`);
            if (startCell) {
                // Calcular posi√ß√£o baseada no √≠ndice da c√©lula no grid
                const cellSize = 47; // 45px width + 2px gap
                const gridPadding = 20; // padding do grid
                
                const left = gameState.start[1] * cellSize + gridPadding + 5; // 5px para centralizar
                const top = gameState.start[0] * cellSize + gridPadding + 5;
                
                character.style.position = 'absolute';
                character.style.left = left + 'px';
                character.style.top = top + 'px';
                
                document.getElementById('grid').style.position = 'relative';
                document.getElementById('grid').appendChild(character);
                
                // Log da cria√ß√£o do personagem
                addLogEntry('system', `Rob√¥ posicionado em <span class="log-coordinates">(${gameState.start[0]},${gameState.start[1]})</span>`);
            }
        }

        function moveCharacterToCell(row, col, callback = null) {
            if (!character) return;
            
            const targetCell = document.getElementById(`cell-${row}-${col}`);
            if (!targetCell) return;
            
            // MARCAR A C√âLULA COMO PISADA IMEDIATAMENTE
            if (!gameState.steppedCells.some(p => p[0] === row && p[1] === col)) {
                gameState.steppedCells.push([row, col]);
                addLogEntry('movement', `üë£ Pisou em <span class="log-coordinates">(${row},${col})</span>`);
                
                // Atualizar visual imediatamente
                updateGridVisually();
            }
            
            // Log do movimento
            addLogEntry('movement', `Movendo para <span class="log-coordinates">(${row},${col})</span>`);
            
            // Calcular nova posi√ß√£o baseada no √≠ndice da c√©lula
            const cellSize = 47; // 45px width + 2px gap
            const gridPadding = 20; // padding do grid
            
            const newLeft = col * cellSize + gridPadding + 5; // 5px para centralizar
            const newTop = row * cellSize + gridPadding + 5;
            
            // Adicionar classe de movimento
            character.classList.add('moving', 'walking');
            
            // Criar rastro na posi√ß√£o atual
            const currentLeft = parseInt(character.style.left);
            const currentTop = parseInt(character.style.top);
            createTrail(currentLeft + 17.5, currentTop + 17.5);
            
            // Animar movimento
            character.style.left = newLeft + 'px';
            character.style.top = newTop + 'px';
            
            // Remover classes ap√≥s anima√ß√£o
            setTimeout(() => {
                if (character) {
                    character.classList.remove('moving', 'walking');
                    if (callback) callback();
                }
            }, 300);
        }

        function createTrail(x, y) {
            const trail = document.createElement('div');
            trail.className = 'trail';
            trail.style.left = (x - 10) + 'px';
            trail.style.top = (y - 10) + 'px';
            
            document.getElementById('grid').appendChild(trail);
            
            // Remove o rastro ap√≥s a anima√ß√£o
            setTimeout(() => {
                if (trail.parentNode) {
                    trail.parentNode.removeChild(trail);
                }
            }, 1000);
        }

        function startWalking() {
            if (isWalking) {
                stopWalking();
                return;
            }
            
            const path = gameState.currentPath;
            if (!path || path.length === 0) {
                addLogEntry('error', 'Nenhum caminho dispon√≠vel! Calcule um caminho primeiro.');
                alert('Nenhum caminho dispon√≠vel! Calcule um caminho primeiro.');
                return;
            }
            
            isWalking = true;
            currentWalkStep = 0;
            document.getElementById('walk-btn').textContent = '‚èπÔ∏è Parar';
            
            addLogEntry('system', `üö∂ Iniciando caminhada - ${path.length} passos planejados`);
            addLogEntry('pathfinding', `Rota: ${path.map(p => `(${p[0]},${p[1]})`).join(' ‚Üí ')}`);
            
            // Come√ßar a caminhada
            walkNextStep();
        }

        function walkNextStep() {
            if (!isWalking || currentWalkStep >= gameState.currentPath.length) {
                // Chegou ao fim
                if (character && currentWalkStep > 0) {
                    const finalPos = gameState.currentPath[currentWalkStep - 1];
                    if (finalPos[0] === gameState.goal[0] && finalPos[1] === gameState.goal[1]) {
                        character.classList.add('celebrating');
                        addLogEntry('success', `üéâ DESTINO ALCAN√áADO! Rob√¥ chegou em <span class="log-coordinates">(${gameState.goal[0]},${gameState.goal[1]})</span>`);
                        addLogEntry('system', `‚úÖ Miss√£o completa em ${currentWalkStep} movimentos!`);
                        setTimeout(() => {
                            if (character) character.classList.remove('celebrating');
                        }, 1000);
                    } else {
                        addLogEntry('error', `‚ùå Caminho incompleto! Parou em <span class="log-coordinates">(${finalPos[0]},${finalPos[1]})</span> em vez de <span class="log-coordinates">(${gameState.goal[0]},${gameState.goal[1]})</span>`);
                    }
                } else {
                    addLogEntry('error', '‚ùå Nenhum movimento realizado!');
                }
                stopWalking();
                return;
            }
            
            const nextPos = gameState.currentPath[currentWalkStep];
            
            // Verificar se a pr√≥xima posi√ß√£o est√° bloqueada
            const isBlocked = gameState.dynamicObstacles.some(obs => 
                obs[0] === nextPos[0] && obs[1] === nextPos[1]
            );
            
            if (isBlocked && currentWalkStep > 0) {
                // Obst√°culo encontrado! Recalcular caminho A PARTIR DA POSI√á√ÉO ATUAL
                const currentPos = gameState.currentPath[currentWalkStep - 1];
                addLogEntry('obstacle', `‚ö†Ô∏è Obst√°culo detectado em <span class="log-coordinates">(${nextPos[0]},${nextPos[1]})</span>!`);
                addLogEntry('pathfinding', `üß† A* Adaptativo ativado - Recalculando de <span class="log-coordinates">(${currentPos[0]},${currentPos[1]})</span>...`);
                
                if (character) {
                    character.classList.add('blocked');
                    setTimeout(() => {
                        if (character) character.classList.remove('blocked');
                    }, 500);
                }
                
                // Simular rec√°lculo do A* Adaptativo MANTENDO A POSI√á√ÉO ATUAL
                setTimeout(() => {
                    gameState.stats.replanningCount++;
                    
                    // Recalcular caminho DA POSI√á√ÉO ATUAL (n√£o do in√≠cio!)
                    const newPath = findPath(currentPos, gameState.goal, gameState.obstacles.concat(gameState.dynamicObstacles));
                    
                    if (newPath.length > 0) {
                        // Manter o caminho j√° percorrido + novo caminho
                        const completedPath = gameState.currentPath.slice(0, currentWalkStep);
                        gameState.currentPath = completedPath.concat(newPath.slice(1)); // Remove duplicata da posi√ß√£o atual
                        gameState.stats.pathLength = gameState.currentPath.length;
                        
                        addLogEntry('pathfinding', `‚ú® Nova rota encontrada! Continuando de <span class="log-coordinates">(${currentPos[0]},${currentPos[1]})</span>`);
                        addLogEntry('pathfinding', `üó∫Ô∏è Nova rota: ${newPath.map(p => `(${p[0]},${p[1]})`).join(' ‚Üí ')}`);
                        
                        // Continuar caminhada do ponto atual (N√ÉO resetar currentWalkStep!)
                        walkNextStep();
                    } else {
                        addLogEntry('error', `üö´ Nenhum caminho alternativo encontrado de <span class="log-coordinates">(${currentPos[0]},${currentPos[1]})</span>! Miss√£o falhou.`);
                        stopWalking();
                    }
                }, 1000);
                return;
            }
            
            // Validar se o movimento √© permitido (c√©lulas adjacentes)
            if (currentWalkStep > 0) {
                const currentPos = gameState.currentPath[currentWalkStep - 1];
                const distance = Math.abs(nextPos[0] - currentPos[0]) + Math.abs(nextPos[1] - currentPos[1]);
                const isDiagonal = Math.abs(nextPos[0] - currentPos[0]) === 1 && Math.abs(nextPos[1] - currentPos[1]) === 1;
                
                if (distance > 2 || (distance === 2 && !isDiagonal)) {
                    addLogEntry('error', `üö´ MOVIMENTO INV√ÅLIDO! Tentativa de pular de <span class="log-coordinates">(${currentPos[0]},${currentPos[1]})</span> para <span class="log-coordinates">(${nextPos[0]},${nextPos[1]})</span>`);
                    addLogEntry('system', 'üîß Recalculando caminho devido a erro de pathfinding...');
                    
                    // For√ßar rec√°lculo do caminho DA POSI√á√ÉO ATUAL
                    setTimeout(() => {
                        gameState.stats.replanningCount++;
                        const newPath = findPath(currentPos, gameState.goal, gameState.obstacles.concat(gameState.dynamicObstacles));
                        
                        if (newPath.length > 0) {
                            const completedPath = gameState.currentPath.slice(0, currentWalkStep);
                            gameState.currentPath = completedPath.concat(newPath.slice(1));
                            gameState.stats.pathLength = gameState.currentPath.length;
                            walkNextStep();
                        } else {
                            addLogEntry('error', 'üö´ Imposs√≠vel continuar - sem caminho v√°lido!');
                            stopWalking();
                        }
                    }, 1000);
                    return;
                }
            }
            
            moveCharacterToCell(nextPos[0], nextPos[1], () => {
                currentWalkStep++;
                addLogEntry('movement', `Passo ${currentWalkStep}/${gameState.currentPath.length} - Posi√ß√£o atual: <span class="log-coordinates">(${nextPos[0]},${nextPos[1]})</span>`);
                
                if (isWalking) {
                    walkingInterval = setTimeout(walkNextStep, walkingSpeed);
                }
            });
        }

        function stopWalking() {
            if (isWalking) {
                addLogEntry('system', '‚èπÔ∏è Caminhada interrompida pelo usu√°rio');
            }
            
            isWalking = false;
            if (walkingInterval) {
                clearTimeout(walkingInterval);
                walkingInterval = null;
            }
            document.getElementById('walk-btn').textContent = 'üö∂ Iniciar Caminhada';
        }

        // Sistema de Log
        function addLogEntry(type, message) {
            const logContainer = document.getElementById('log-container');
            const logEntry = document.createElement('div');
            logEntry.className = `log-entry ${type}`;
            
            const currentTime = new Date();
            const timeString = currentTime.toLocaleTimeString('pt-BR', { 
                hour12: false,
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit'
            });
            
            logEntry.innerHTML = `
                <span class="log-time">${timeString}</span>
                <span class="log-message">${message}</span>
            `;
            
            logContainer.appendChild(logEntry);
            
            // Auto-scroll para o final se ativado
            if (autoScroll) {
                logContainer.scrollTop = logContainer.scrollHeight;
            }
            
            // Limitar n√∫mero de entradas (manter √∫ltimas 100)
            const entries = logContainer.querySelectorAll('.log-entry');
            if (entries.length > 100) {
                entries[0].remove();
            }
        }

        function clearLog() {
            const logContainer = document.getElementById('log-container');
            logContainer.innerHTML = '';
            addLogEntry('system', 'Log limpo - Sistema reiniciado');
        }

        function toggleAutoScroll() {
            autoScroll = !autoScroll;
            const btn = document.getElementById('auto-scroll-btn');
            btn.textContent = `üìú Auto-scroll: ${autoScroll ? 'ON' : 'OFF'}`;
        }

        function handleCellClick(row, col) {
            if ((row === gameState.start[0] && col === gameState.start[1]) ||
                (row === gameState.goal[0] && col === gameState.goal[1])) {
                return; // N√£o permite modificar in√≠cio/fim
            }
            
            // N√ÉO parar caminhada - deixar o algoritmo adaptativo funcionar!
            // Se o rob√¥ estiver caminhando, ele vai detectar o obst√°culo e recalcular
            
            const isObstacle = gameState.obstacles.some(obs => obs[0] === row && obs[1] === col);
            const isDynamicObstacle = gameState.dynamicObstacles.some(obs => obs[0] === row && obs[1] === col);
            
            if (isObstacle) {
                // Remove obst√°culo est√°tico
                gameState.obstacles = gameState.obstacles.filter(obs => !(obs[0] === row && obs[1] === col));
                addLogEntry('system', `Obst√°culo removido de <span class="log-coordinates">(${row},${col})</span>`);
            } else if (isDynamicObstacle) {
                // Remove obst√°culo din√¢mico
                gameState.dynamicObstacles = gameState.dynamicObstacles.filter(obs => !(obs[0] === row && obs[1] === col));
                gameState.stats.dynamicObstacles--;
                addLogEntry('system', `Pok√©mon removido de <span class="log-coordinates">(${row},${col})</span>`);
            } else {
                // Adiciona obst√°culo din√¢mico
                gameState.dynamicObstacles.push([row, col]);
                gameState.stats.dynamicObstacles++;
                gameState.stats.replanningCount++;
                addLogEntry('obstacle', `üêõ Pok√©mon apareceu em <span class="log-coordinates">(${row},${col})</span>!`);
                
                // Se o rob√¥ estiver caminhando, ele vai detectar o obst√°culo automaticamente
                if (isWalking) {
                    addLogEntry('system', 'üéØ Rob√¥ detectar√° o obst√°culo no pr√≥ximo movimento...');
                }
            }
            
            // SEMPRE atualizar o visual, independente se est√° caminhando ou n√£o
            if (isWalking) {
                // Durante caminhada: apenas atualizar visual
                updateGridVisually();
                updateStats();
            } else {
                // Parado: recalcular caminho completo
                calculateAndShowPath();
            }
        }

        function calculateAndShowPath() {
            // Simula√ß√£o simplificada do A*
            const path = findPath(gameState.start, gameState.goal, gameState.obstacles.concat(gameState.dynamicObstacles));
            gameState.currentPath = path;
            gameState.stats.pathLength = path.length;
            gameState.stats.cellsProcessed += path.length;
            
            createGrid();
        }

        function findPath(start, goal, obstacles) {
            // Implementa√ß√£o corrigida do A* que n√£o permite saltos imposs√≠veis
            const openSet = [];
            const closedSet = new Set();
            const cameFrom = new Map();
            const gScore = new Map();
            const fScore = new Map();
            
            // Fun√ß√£o para converter posi√ß√£o em string para usar como chave
            const posKey = (pos) => `${pos[0]},${pos[1]}`;
            
            // Fun√ß√£o heur√≠stica (dist√¢ncia Manhattan)
            const heuristic = (a, b) => Math.abs(a[0] - b[0]) + Math.abs(a[1] - b[1]);
            
            // Fun√ß√£o para obter vizinhos v√°lidos (apenas c√©lulas adjacentes)
            const getNeighbors = (pos) => {
                const neighbors = [];
                const [row, col] = pos;
                
                // 8 dire√ß√µes poss√≠veis (incluindo diagonais)
                const directions = [
                    [-1, -1], [-1, 0], [-1, 1],
                    [0, -1],           [0, 1],
                    [1, -1],  [1, 0],  [1, 1]
                ];
                
                for (const [dr, dc] of directions) {
                    const newRow = row + dr;
                    const newCol = col + dc;
                    
                    // Verificar se est√° dentro dos limites
                    if (newRow >= 0 && newRow < GRID_SIZE && newCol >= 0 && newCol < GRID_SIZE) {
                        // Verificar se n√£o √© obst√°culo
                        if (!obstacles.some(obs => obs[0] === newRow && obs[1] === newCol)) {
                            neighbors.push([newRow, newCol]);
                        }
                    }
                }
                
                return neighbors;
            };
            
            // Inicializar
            const startKey = posKey(start);
            const goalKey = posKey(goal);
            
            openSet.push({pos: start, f: heuristic(start, goal)});
            gScore.set(startKey, 0);
            fScore.set(startKey, heuristic(start, goal));
            
            while (openSet.length > 0) {
                // Ordenar por f-score e pegar o melhor
                openSet.sort((a, b) => a.f - b.f);
                const current = openSet.shift();
                const currentKey = posKey(current.pos);
                
                // Chegou no objetivo
                if (currentKey === goalKey) {
                    const path = [];
                    let temp = current.pos;
                    let tempKey = posKey(temp);
                    
                    while (cameFrom.has(tempKey)) {
                        path.unshift(temp);
                        temp = cameFrom.get(tempKey);
                        tempKey = posKey(temp);
                    }
                    path.unshift(start);
                    
                    return path;
                }
                
                closedSet.add(currentKey);
                
                // Examinar vizinhos
                for (const neighbor of getNeighbors(current.pos)) {
                    const neighborKey = posKey(neighbor);
                    
                    if (closedSet.has(neighborKey)) {
                        continue;
                    }
                    
                    // Calcular custo do movimento (diagonal = 1.4, ortogonal = 1.0)
                    const moveCost = (Math.abs(neighbor[0] - current.pos[0]) + Math.abs(neighbor[1] - current.pos[1])) === 2 ? 1.4 : 1.0;
                    const tentativeGScore = gScore.get(currentKey) + moveCost;
                    
                    if (!gScore.has(neighborKey) || tentativeGScore < gScore.get(neighborKey)) {
                        cameFrom.set(neighborKey, current.pos);
                        gScore.set(neighborKey, tentativeGScore);
                        const fScoreValue = tentativeGScore + heuristic(neighbor, goal);
                        fScore.set(neighborKey, fScoreValue);
                        
                        // Adicionar √† lista aberta se n√£o estiver l√°
                        if (!openSet.some(item => posKey(item.pos) === neighborKey)) {
                            openSet.push({pos: neighbor, f: fScoreValue});
                        }
                    }
                }
            }
            
            // N√£o encontrou caminho
            return [];
        }

        function addRandomObstacle() {
            let attempts = 0;
            while (attempts < 20) {
                const row = Math.floor(Math.random() * GRID_SIZE);
                const col = Math.floor(Math.random() * GRID_SIZE);
                
                if ((row !== gameState.start[0] || col !== gameState.start[1]) &&
                    (row !== gameState.goal[0] || col !== gameState.goal[1]) &&
                    !gameState.obstacles.some(obs => obs[0] === row && obs[1] === col) &&
                    !gameState.dynamicObstacles.some(obs => obs[0] === row && obs[1] === col)) {
                    
                    gameState.obstacles.push([row, col]);
                    
                    addLogEntry('obstacle', `üé≤ Obst√°culo aleat√≥rio criado em <span class="log-coordinates">(${row},${col})</span>`);
                    
                    // SEMPRE atualizar visual
                    if (isWalking) {
                        updateGridVisually();
                        updateStats();
                        addLogEntry('system', 'üéØ Rob√¥ detectar√° o obst√°culo no pr√≥ximo movimento...');
                    } else {
                        if (currentMode === 'interactive') {
                            calculateAndShowPath();
                        } else {
                            createGrid(demoSteps[currentStepIndex]);
                        }
                    }
                    break;
                }
                attempts++;
            }
        }

        function addRandomPokemon() {
            let attempts = 0;
            while (attempts < 20) {
                const row = Math.floor(Math.random() * GRID_SIZE);
                const col = Math.floor(Math.random() * GRID_SIZE);
                
                if ((row !== gameState.start[0] || col !== gameState.start[1]) &&
                    (row !== gameState.goal[0] || col !== gameState.goal[1]) &&
                    !gameState.obstacles.some(obs => obs[0] === row && obs[1] === col) &&
                    !gameState.dynamicObstacles.some(obs => obs[0] === row && obs[1] === col)) {
                    
                    gameState.dynamicObstacles.push([row, col]);
                    gameState.stats.dynamicObstacles++;
                    gameState.stats.replanningCount++;
                    
                    addLogEntry('obstacle', `üêõ Pok√©mon aleat√≥rio apareceu em <span class="log-coordinates">(${row},${col})</span>`);
                    
                    // SEMPRE atualizar visual
                    if (isWalking) {
                        updateGridVisually();
                        updateStats();
                        addLogEntry('system', 'üéØ Rob√¥ detectar√° o pok√©mon no pr√≥ximo movimento...');
                    } else {
                        if (currentMode === 'interactive') {
                            calculateAndShowPath();
                        } else {
                            createGrid(demoSteps[currentStepIndex]);
                        }
                    }
                    break;
                }
                attempts++;
            }
        }

        function clearFootprints() {
            gameState.visitedCells = [];
            gameState.steppedCells = [];
            gameState.detourCells = [];
            gameState.isOnDetour = false;
            
            addLogEntry('system', 'üë£ Pegadas do rob√¥ limpas');
            
            if (isWalking) {
                updateGridVisually();
            } else {
                if (currentMode === 'interactive') {
                    calculateAndShowPath();
                } else if (currentMode === 'custom') {
                    updateGridVisually();
                } else {
                    createGrid(demoSteps[currentStepIndex]);
                }
            }
        }

        // === SISTEMA DE DESENHO DE CAMINHO PERSONALIZADO ===
        
        function enablePathDrawing() {
            isDrawingPath = false;
            addLogEntry('system', 'üé® Modo de desenho ativado! Clique "Iniciar Desenho" para come√ßar.');
            createGrid(); // Recriar grid no modo desenho
        }
        
        function disablePathDrawing() {
            isDrawingPath = false;
            isMouseDown = false;
        }
        
        function togglePathDrawing() {
            isDrawingPath = !isDrawingPath;
            const btn = document.getElementById('draw-toggle-btn');
            
            if (isDrawingPath) {
                btn.textContent = 'üõë Parar Desenho';
                btn.className = 'danger';
                addLogEntry('system', '‚úèÔ∏è Desenho ativado! Clique e arraste para desenhar o caminho.');
            } else {
                btn.textContent = '‚úèÔ∏è Iniciar Desenho';
                btn.className = 'success';
                addLogEntry('system', 'üõë Desenho desativado.');
            }
        }
        
        function handlePathDrawingStart(row, col, event) {
            if (!isDrawingPath) return;
            
            event.preventDefault();
            isMouseDown = true;
            
            // N√£o desenhar em obst√°culos ou in√≠cio/fim
            if ((row === gameState.start[0] && col === gameState.start[1]) ||
                (row === gameState.goal[0] && col === gameState.goal[1]) ||
                gameState.obstacles.some(obs => obs[0] === row && obs[1] === col) ||
                gameState.dynamicObstacles.some(obs => obs[0] === row && obs[1] === col)) {
                return;
            }
            
            // Adicionar ao caminho personalizado
            if (!gameState.customPath.some(p => p[0] === row && p[1] === col)) {
                gameState.customPath.push([row, col]);
                addLogEntry('system', `‚úèÔ∏è Adicionado ao caminho: <span class="log-coordinates">(${row},${col})</span>`);
                updateGridVisually();
            }
        }
        
        function handlePathDrawingMove(row, col) {
            if (!isDrawingPath || !isMouseDown) return;
            
            // N√£o desenhar em obst√°culos ou in√≠cio/fim
            if ((row === gameState.start[0] && col === gameState.start[1]) ||
                (row === gameState.goal[0] && col === gameState.goal[1]) ||
                gameState.obstacles.some(obs => obs[0] === row && obs[1] === col) ||
                gameState.dynamicObstacles.some(obs => obs[0] === row && obs[1] === col)) {
                return;
            }
            
            // Adicionar ao caminho personalizado se n√£o existir
            if (!gameState.customPath.some(p => p[0] === row && p[1] === col)) {
                gameState.customPath.push([row, col]);
                updateGridVisually();
            }
        }
        
        function handlePathDrawingEnd(row, col) {
            if (!isDrawingPath) return;
            isMouseDown = false;
        }
        
        function addWaypoint() {
            addLogEntry('system', '‚≠ê Modo Waypoint ativado! Clique nas c√©lulas para definir pontos obrigat√≥rios.');
            
            // Temporariamente ativar modo waypoint
            const cells = document.querySelectorAll('.cell');
            cells.forEach(cell => {
                const originalClick = cell.onclick;
                cell.onclick = function(e) {
                    const row = parseInt(cell.dataset.row);
                    const col = parseInt(cell.dataset.col);
                    
                    // N√£o permitir waypoint em obst√°culos
                    if (gameState.obstacles.some(obs => obs[0] === row && obs[1] === col) ||
                        gameState.dynamicObstacles.some(obs => obs[0] === row && obs[1] === col)) {
                        return;
                    }
                    
                    // Toggle waypoint
                    const existingIndex = gameState.waypoints.findIndex(w => w[0] === row && w[1] === col);
                    if (existingIndex >= 0) {
                        gameState.waypoints.splice(existingIndex, 1);
                        addLogEntry('system', `‚≠ê Waypoint removido de <span class="log-coordinates">(${row},${col})</span>`);
                    } else {
                        gameState.waypoints.push([row, col]);
                        addLogEntry('system', `‚≠ê Waypoint adicionado em <span class="log-coordinates">(${row},${col})</span>`);
                    }
                    
                    updateGridVisually();
                    
                    // Restaurar click original depois de um tempo
                    setTimeout(() => {
                        cell.onclick = originalClick;
                    }, 100);
                };
            });
        }
        
        function clearCustomPath() {
            gameState.customPath = [];
            gameState.waypoints = [];
            gameState.currentPath = []; // Limpar caminho atual tamb√©m
            
            addLogEntry('system', 'üóëÔ∏è Desenho e waypoints apagados');
            updateGridVisually();
        }
        
        function followCustomPath() {
            if (gameState.customPath.length === 0 && gameState.waypoints.length === 0) {
                addLogEntry('error', '‚ùå Nenhum caminho desenhado! Desenhe um caminho primeiro.');
                alert('Desenhe um caminho primeiro usando "Iniciar Desenho" ou "Modo Waypoint"!');
                return;
            }
            
            // Parar caminhada se estiver ativa
            if (isWalking) {
                stopWalking();
            }
            
            // Criar caminho baseado no desenho do usu√°rio
            let finalPath = [];
            
            if (gameState.waypoints.length > 0) {
                // WAYPOINTS: Usar A* para conectar os pontos
                addLogEntry('pathfinding', `‚≠ê Processando ${gameState.waypoints.length} waypoints...`);
                
                let currentPos = gameState.start;
                finalPath.push(currentPos);
                
                for (let i = 0; i < gameState.waypoints.length; i++) {
                    const waypoint = gameState.waypoints[i];
                    const pathSegment = findPath(currentPos, waypoint, gameState.obstacles.concat(gameState.dynamicObstacles));
                    
                    if (pathSegment.length > 0) {
                        finalPath = finalPath.concat(pathSegment.slice(1));
                        currentPos = waypoint;
                        addLogEntry('pathfinding', `‚úÖ Waypoint ${i+1} conectado: <span class="log-coordinates">(${waypoint[0]},${waypoint[1]})</span>`);
                    } else {
                        addLogEntry('error', `‚ùå N√£o foi poss√≠vel conectar ao waypoint <span class="log-coordinates">(${waypoint[0]},${waypoint[1]})</span>`);
                    }
                }
                
                const finalSegment = findPath(currentPos, gameState.goal, gameState.obstacles.concat(gameState.dynamicObstacles));
                if (finalSegment.length > 0) {
                    finalPath = finalPath.concat(finalSegment.slice(1));
                    addLogEntry('pathfinding', `üéØ Caminho final para destino conectado`);
                }
                
            } else if (gameState.customPath.length > 0) {
                // DESENHO LIVRE: Usar EXATAMENTE o caminho desenhado
                addLogEntry('pathfinding', `‚úèÔ∏è Seguindo caminho desenhado EXATAMENTE como foi feito...`);
                
                // Conectar in√≠cio ao primeiro ponto do desenho com A*
                const firstPoint = gameState.customPath[0];
                const startSegment = findPath(gameState.start, firstPoint, gameState.obstacles.concat(gameState.dynamicObstacles));
                
                if (startSegment.length > 0) {
                    finalPath = startSegment;
                    addLogEntry('pathfinding', `üîó Conectado in√≠cio <span class="log-coordinates">(${gameState.start[0]},${gameState.start[1]})</span> ao primeiro desenho <span class="log-coordinates">(${firstPoint[0]},${firstPoint[1]})</span>`);
                } else {
                    addLogEntry('error', '‚ùå N√£o foi poss√≠vel conectar ao in√≠cio do caminho desenhado');
                    return;
                }
                
                // Adicionar EXATAMENTE os pontos desenhados na ORDEM ORIGINAL
                for (let i = 1; i < gameState.customPath.length; i++) {
                    const currentPoint = gameState.customPath[i];
                    const previousPoint = gameState.customPath[i-1];
                    
                    // Verificar se o movimento √© v√°lido (c√©lulas adjacentes)
                    const distance = Math.abs(currentPoint[0] - previousPoint[0]) + Math.abs(currentPoint[1] - previousPoint[1]);
                    const isDiagonal = Math.abs(currentPoint[0] - previousPoint[0]) === 1 && Math.abs(currentPoint[1] - previousPoint[1]) === 1;
                    
                    if (distance <= 2 && (distance <= 1 || isDiagonal)) {
                        // Movimento v√°lido - adicionar diretamente
                        finalPath.push(currentPoint);
                    } else {
                        // Movimento inv√°lido - usar A* para conectar estes dois pontos
                        addLogEntry('pathfinding', `üîó Conectando <span class="log-coordinates">(${previousPoint[0]},${previousPoint[1]})</span> ‚Üí <span class="log-coordinates">(${currentPoint[0]},${currentPoint[1]})</span> com A*`);
                        const connectionSegment = findPath(previousPoint, currentPoint, gameState.obstacles.concat(gameState.dynamicObstacles));
                        
                        if (connectionSegment.length > 0) {
                            finalPath = finalPath.concat(connectionSegment.slice(1)); // Remove duplicata
                        } else {
                            addLogEntry('error', `‚ùå N√£o foi poss√≠vel conectar pontos do desenho`);
                            finalPath.push(currentPoint); // Adicionar mesmo assim
                        }
                    }
                }
                
                // Conectar √∫ltimo ponto ao destino com A*
                const lastPoint = gameState.customPath[gameState.customPath.length - 1];
                if (lastPoint[0] !== gameState.goal[0] || lastPoint[1] !== gameState.goal[1]) {
                    const endSegment = findPath(lastPoint, gameState.goal, gameState.obstacles.concat(gameState.dynamicObstacles));
                    
                    if (endSegment.length > 0) {
                        finalPath = finalPath.concat(endSegment.slice(1));
                        addLogEntry('pathfinding', `üéØ Conectado √∫ltimo desenho <span class="log-coordinates">(${lastPoint[0]},${lastPoint[1]})</span> ao destino <span class="log-coordinates">(${gameState.goal[0]},${gameState.goal[1]})</span>`);
                    }
                }
            }
            
            // Validar caminho final
            if (finalPath.length === 0) {
                addLogEntry('error', '‚ùå N√£o foi poss√≠vel criar caminho v√°lido');
                return;
            }
            
            // VALIDA√á√ÉO FINAL: Verificar se n√£o h√° saltos imposs√≠veis
            const validatedPath = [];
            validatedPath.push(finalPath[0]);
            
            for (let i = 1; i < finalPath.length; i++) {
                const current = finalPath[i];
                const previous = finalPath[i-1];
                
                const distance = Math.abs(current[0] - previous[0]) + Math.abs(current[1] - previous[1]);
                const isDiagonal = Math.abs(current[0] - previous[0]) === 1 && Math.abs(current[1] - previous[1]) === 1;
                
                if (distance <= 2 && (distance <= 1 || isDiagonal)) {
                    validatedPath.push(current);
                } else {
                    // Salto inv√°lido detectado - usar A* para corrigir
                    addLogEntry('error', `üö´ Salto inv√°lido detectado: <span class="log-coordinates">(${previous[0]},${previous[1]})</span> ‚Üí <span class="log-coordinates">(${current[0]},${current[1]})</span>`);
                    const fixSegment = findPath(previous, current, gameState.obstacles.concat(gameState.dynamicObstacles));
                    
                    if (fixSegment.length > 0) {
                        validatedPath.push(...fixSegment.slice(1));
                    } else {
                        validatedPath.push(current); // Fallback
                    }
                }
            }
            
            // Aplicar o caminho validado
            gameState.currentPath = validatedPath;
            gameState.stats.pathLength = validatedPath.length;
            
            addLogEntry('success', `üöÄ Caminho personalizado criado com ${validatedPath.length} passos!`);
            addLogEntry('pathfinding', `üó∫Ô∏è Rota: ${validatedPath.slice(0, 10).map(p => `(${p[0]},${p[1]})`).join(' ‚Üí ')}${validatedPath.length > 10 ? '...' : ''}`);
            
            // Atualizar visual
            updateGridVisually();
            
            // Iniciar caminhada automaticamente
            setTimeout(() => {
                startWalking();
            }, 1000);
        }

        function clearObstacles() {
            gameState.dynamicObstacles = [];
            gameState.stats.dynamicObstacles = 0;
            
            if (currentMode === 'interactive') {
                calculateAndShowPath();
            } else {
                createGrid(demoSteps[currentStepIndex]);
            }
        }

        function nextStep() {
            if (currentStepIndex < demoSteps.length - 1) {
                currentStepIndex++;
                createGrid(demoSteps[currentStepIndex]);
            }
        }

        function resetDemo() {
            currentStepIndex = 0;
            stopWalking(); // Para qualquer caminhada em andamento
            
            gameState.stats = {
                cellsProcessed: 0,
                dynamicObstacles: 0,
                replanningCount: 0,
                pathLength: 0
            };
            
            // Limpar rastros visuais
            gameState.visitedCells = [];
            gameState.steppedCells = [];
            gameState.detourCells = [];
            gameState.customPath = [];
            gameState.waypoints = [];
            gameState.isOnDetour = false;
            
            if (autoPlayInterval) {
                clearInterval(autoPlayInterval);
                autoPlayInterval = null;
            }
            
            if (currentMode === 'demo') {
                createGrid(demoSteps[0]);
            } else {
                calculateAndShowPath();
            }
        }

        function autoPlay() {
            if (autoPlayInterval) {
                clearInterval(autoPlayInterval);
                autoPlayInterval = null;
                document.getElementById('auto-btn').textContent = '‚èØÔ∏è Auto Play';
                return;
            }
            
            document.getElementById('auto-btn').textContent = '‚è∏Ô∏è Pausar';
            autoPlayInterval = setInterval(() => {
                if (currentStepIndex < demoSteps.length - 1) {
                    nextStep();
                } else {
                    clearInterval(autoPlayInterval);
                    autoPlayInterval = null;
                    document.getElementById('auto-btn').textContent = '‚èØÔ∏è Auto Play';
                }
            }, playbackSpeed);
        }

        // Inicializa√ß√£o
        window.addEventListener('load', function() {
            createGrid(demoSteps[0]);
            
            // Adicionar eventos globais do mouse para desenho
            document.addEventListener('mouseup', () => {
                isMouseDown = false;
            });
        });
    </script>
</body>
</html>